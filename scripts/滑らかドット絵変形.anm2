--label:変形
--information:https://github.com/sevenc-nanashi/aviutl2-scripts/blob/main/scripts/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5%E5%A4%89%E5%BD%A2.anm2

-- ========================================================================================================================
-- cleanEdgeで拡大縮小・回転・中心移動を行うスクリプト。
-- ドット絵変形と違い、これはドット絵でも綺麗に変形されます。
--
-- cleanEdgeについてはこれを参照してください：https://torcado.com/cleanEdge/
--
-- 一部パラメーターの説明：
-- - 基準色：線の上書き判定に使う色。例えば#ffffffの場合は明るい色が優先されます。もしドット絵に外枠がある場合は、外枠を設定すると綺麗になります。
--           cleanEdgeのHighest Colorに相当します。
-- - 線の太さ：線の太さを指定します。ピクセルが何マス分に広がるかを指定します。45度の線を綺麗にしたい場合は0.707付近にしてください。
--             cleanEdgeのLine Widthに相当します。
-- - 傾斜モード：拡大時に傾斜を滑らかにするかどうかを指定します。
--               cleanEdgeのSlopesに相当します。
--
--
-- PI:
-- - scale_x: X拡大率（1.0で等倍）
-- - scale_y: Y拡大率（1.0で等倍）
-- - center_x: 中心X（ピクセル単位）
-- - center_y: 中心Y（ピクセル単位）
-- - angle_deg: 回転（度）
-- - highest_color: 線の上書き判定に使う色。
-- - line_width: 線の太さ。
-- - slopes: 拡大時に傾斜を滑らかにするかどうか（0：しない、1：1:1のみ滑らかにする、2：1:1と1:2を滑らかにする）
-- - debug: デバッググリッドの表示（0で非表示、正の値でグリッドサイズ）
--
-- https://aviutl2-scripts-download.sevenc7c.workers.dev/%E6%BB%91%E3%82%89%E3%81%8B%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5%E5%A4%89%E5%BD%A2.anm2
-- ========================================================================================================================


-- このスクリプトはcleanEdgeをベースに作成しました。
-- 以下はcleanEdgeのライセンス情報です。
-- --------------------------------------------------------------------------------
-- Copyright (c) 2022 torcado
-- Permission is hereby granted, free of charge, to any person
-- obtaining a copy of this software and associated documentation
-- files (the "Software"), to deal in the Software without
-- restriction, including without limitation the rights to use,
-- copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following
-- conditions:
-- The above copyright notice and this permission notice shall be
-- included in all copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-- OTHER DEALINGS IN THE SOFTWARE.
-- --------------------------------------------------------------------------------

--group:中心移動,true

--track@center_x:中心X,-5000,5000,0,0.01
--track@center_y:中心Y,-5000,5000,0,0.01
--group:拡大縮小,true

--track@scale_x:X拡大率,1,10000,100,0.001
--track@scale_y:Y拡大率,1,10000,100,0.001
--group:回転,true

--track@angle_deg:回転（度）,-360,360,0,0.1
--group:高度な設定,false
--track@debug:透明グリッド,0,1000,0,1
--value@PI:PI,{}
--[[pixelshader@debug_grid:
Texture2D tex0 : register(t0);
SamplerState sampler0 : register(s0);
cbuffer cb0 : register(b0)
{
    float size;
};

float4 debug_grid(float4 pos: SV_Position, float2 uv: TEXCOORD) : SV_Target
{
  float checker = fmod(floor(pos.x / size) + floor(pos.y / size), 2.0);

  if (checker < 1.0)
  {
    return float4(0.25, 0.25, 0.25, 1);
  }
  else
  {
    return float4(0, 0, 0, 1);
  }
}

// vim: set ft=hlsl ts=4 sts=4 sw=4 noet:

]]
--[[pixelshader@transform:
Texture2D tex0 : register(t0);
SamplerState sampler0 : register(s0);

cbuffer cb0 : register(b0)
{
    float min_x;
    float min_y;
    float base_w;
    float base_h;
    float center_x;
    float center_y;
    float scale_x;
    float scale_y;
    float angle;
};

float2 rotate_point(float x, float y, float angle)
{
    float cos_a = cos(angle);
    float sin_a = sin(angle);
    float rx = cos_a * x - sin_a * y;
    float ry = sin_a * x + cos_a * y;
    return float2(rx, ry);
}

float4 transform(float4 pos: SV_Position, float2 uv: TEXCOORD) : SV_Target
{
    float new_x = min_x + pos.x;
    float new_y = min_y + pos.y;

    float rel_x = new_x - center_x;
    float rel_y = new_y - center_y;

    float2 rotated = rotate_point(rel_x, rel_y, -angle);
    float2 scaled = float2(rotated.x / scale_x, rotated.y / scale_y);

    float sample_x = scaled.x + center_x;
    float sample_y = scaled.y + center_y;

    if (sample_x < 0 || sample_x >= base_w || sample_y < 0 || sample_y >= base_h)
    {
        // NOTE: sampler = "dot"は範囲外を透明にするという仕様になっているけど一応明示的に透明にする
        return float4(0, 0, 0, 0);
    }
    else
    {
        float2 sample_uv = float2(sample_x / base_w, sample_y / base_h);
        return tex0.Sample(sampler0, sample_uv);
    }
}

// vim: set ft=hlsl ts=4 sts=4 sw=4 noet:

]]

if type(PI.scale_x) == "number" then
  scale_x = PI.scale_x * 100
end
if type(PI.scale_y) == "number" then
  scale_y = PI.scale_y * 100
end
if type(PI.center_x) == "number" then
  center_x = PI.center_x
end
if type(PI.center_y) == "number" then
  center_y = PI.center_y
end
if type(PI.angle_deg) == "number" then
  angle_deg = PI.angle_deg
end
if type(PI.debug) == "boolean" then
  if PI.debug then
    debug = 10
  else
    debug = 0
  end
elseif type(PI.debug) == "number" then
  debug = PI.debug
end

local rscale_x = scale_x / 100
local rscale_y = scale_y / 100

local function rotate_point(x, y, angle_rad)
    -- ( cos theta, -sin theta ) ( x )
    -- ( sin theta,  cos theta ) ( y )
    local cos_a = math.cos(angle_rad)
    local sin_a = math.sin(angle_rad)
    local rx = cos_a * x - sin_a * y
    local ry = sin_a * x + cos_a * y
    return rx, ry
end

local original_cx = obj.cx
local original_cy = obj.cy
local original_sx = obj.sx
local original_sy = obj.sy

obj.setoption("sampler", "dot")

local vanilla_cx = obj.w / 2
local vanilla_cy = obj.h / 2

local cx = vanilla_cx + center_x
local cy = vanilla_cy + center_y

local angle_rad = math.rad(angle_deg)

local left_top_x, left_top_y = rotate_point(-cx * rscale_x, -cy * rscale_y, angle_rad)
local right_top_x, right_top_y = rotate_point((obj.w - cx) * rscale_x, -cy * rscale_y, angle_rad)
local left_bottom_x, left_bottom_y = rotate_point(-cx * rscale_x, (obj.h - cy) * rscale_y, angle_rad)
local right_bottom_x, right_bottom_y = rotate_point((obj.w - cx) * rscale_x, (obj.h - cy) * rscale_y, angle_rad)
left_top_x = left_top_x + cx
left_top_y = left_top_y + cy
right_top_x = right_top_x + cx
right_top_y = right_top_y + cy
left_bottom_x = left_bottom_x + cx
left_bottom_y = left_bottom_y + cy
right_bottom_x = right_bottom_x + cx
right_bottom_y = right_bottom_y + cy

local min_x = math.min(left_top_x, right_top_x, left_bottom_x, right_bottom_x)
local max_x = math.max(left_top_x, right_top_x, left_bottom_x, right_bottom_x)
local min_y = math.min(left_top_y, right_top_y, left_bottom_y, right_bottom_y)
local max_y = math.max(left_top_y, right_top_y, left_bottom_y, right_bottom_y)

local transform_source
if debug > 0 then
  obj.setoption("drawtarget", "tempbuffer", math.ceil(obj.w), math.ceil(obj.h))
  obj.pixelshader("debug_grid", "tempbuffer", {}, {debug})
  obj.draw()
  obj.setoption("draw_state", false)
  obj.copybuffer("cache:debug_grid", "tempbuffer")
  transform_source = "cache:debug_grid"
else
  transform_source = "object"
end
obj.setoption("drawtarget", "tempbuffer", math.ceil(max_x) - math.floor(min_x), math.ceil(max_y) - math.floor(min_y))
obj.pixelshader("transform", "tempbuffer", transform_source, {
  math.floor(min_x),
  math.floor(min_y),
  obj.w,
  obj.h,
  cx,
  cy,
  rscale_x,
  rscale_y,
  angle_rad
}, "copy", "dot")
obj.load("tempbuffer")

local new_cx, new_cy = rotate_point(center_x * rscale_x, center_y * rscale_y, angle_rad)
obj.cx = original_cx + new_cx
obj.cy = original_cy + new_cy

